module approximator
(
input clk,
input en,
input [9:0] data,
input [7:0] modul_step,
input [3:0] fractional_step,
output [9:0] amp
);
	parameter [19:0] dc_amp = 11'd0 * 9'd255; // постоянная составляющая сигнала
	
	wire [10:0] cnt_iteration; // счетчик итераций
	counter #(.WIDTH(11)) counter(.clk(clk), .en(en), .cnt(cnt_iteration));
	
	//-------------adc -> reg----------------------
	wire [19:0] correct_adc, correct_adc_reg;
	signed_mult #(.WIDTH_A(11), .WIDTH_B(9)) mult_adc_const(.a({1'b0,data}), .b(9'd255), .m(correct_adc));
	registor #(.WIDTH(20)) reg_adc(.clk(clk), .en(en), .d(correct_adc - dc_amp), .q(correct_adc_reg));
	//---------------------------------------------
	
	//-------------Table---------------------------
	wire [8:0] cos, sin;
	table_sin_cos table_sin_cos(.clk(clk), .en(en), .modul_step(modul_step), .fractional_step(fractional_step), .cos(cos), .sin(sin));
	//---------------------------------------------
	
	//-------------Линии задержки------------------
	reg [2:0] line_delay1;
	reg [1:0] line_delay2;
	always @(posedge clk) begin
		line_delay1 <= {line_delay1[1:0], en};
		line_delay2 <= {line_delay2[0], &cnt_iteration};
	end
	//---------------------------------------------
	
	//-------------Fc, Fs, C, S, d-----------------
	wire [17:0] sin2, cos2, sin_cos;
	wire [28:0] adc_sin, adc_cos;
	wire [40:0] Fs, Fc;
	wire [29:0] S, C, d;
	signed_mult #(.WIDTH_A(9), .WIDTH_B(9)) mult_sin_sin(.a(sin), .b(sin), .m(sin2));
	signed_mult #(.WIDTH_A(9), .WIDTH_B(9)) mult_cos_cos(.a(cos), .b(cos), .m(cos2));
	signed_mult #(.WIDTH_A(9), .WIDTH_B(9)) mult_sin_cos(.a(sin), .b(cos), .m(sin_cos));
	signed_mult #(.WIDTH_A(20), .WIDTH_B(9)) mult_adc_sin(.a(correct_adc_reg), .b(sin), .m(adc_sin));
	signed_mult #(.WIDTH_A(20), .WIDTH_B(9)) mult_adc_cos(.a(correct_adc_reg), .b(cos), .m(adc_cos));
	
	accumulator #(.WIDTH(29)) accum_Fs(.clk(clk), .en(line_delay1[1]), .reset(line_delay1[2] & line_delay2[1]), .a(adc_sin), .s(Fs));
	accumulator #(.WIDTH(29)) accum_Fc(.clk(clk), .en(line_delay1[1]), .reset(line_delay1[2] & line_delay2[1]), .a(adc_cos), .s(Fc));
	accumulator #(.WIDTH(18)) accum_S(.clk(clk), .en(line_delay1[1]), .reset(line_delay1[2] & line_delay2[1]), .a(sin2), .s(S));
	accumulator #(.WIDTH(18)) accum_C(.clk(clk), .en(line_delay1[1]), .reset(line_delay1[2] & line_delay2[1]), .a(cos2), .s(C));
	accumulator #(.WIDTH(18)) accum_d(.clk(clk), .en(line_delay1[1]), .reset(line_delay1[2] & line_delay2[1]), .a(sin_cos), .s(d));

	//---------------------------------------------
	
	
	
	//------------A, B, delta---------------------
	wire [70:0] Fs_d, Fc_s, A;
	wire [70:0] Fc_d, Fs_c, B;
	wire [59:0] C_S, d2; // delta;
	
	signed_mult #(.WIDTH_A(41), .WIDTH_B(30)) mult_Fs_d(.a(Fs), .b(d), .m(Fs_d));
	signed_mult #(.WIDTH_A(41), .WIDTH_B(30)) mult_Fc_s(.a(Fc), .b(S), .m(Fc_s));
	assign A = Fc_s - Fs_d;
	
	signed_mult #(.WIDTH_A(41), .WIDTH_B(30)) mult_Fc_d(.a(Fc), .b(d), .m(Fc_d));
	signed_mult #(.WIDTH_A(41), .WIDTH_B(30)) mult_Fs_c(.a(Fs), .b(C), .m(Fs_c));
	assign B = Fs_c - Fc_d;
	
	signed_mult #(.WIDTH_A(30), .WIDTH_B(30)) mult_C_S(.a(C), .b(S), .m(C_S));
	signed_mult #(.WIDTH_A(30), .WIDTH_B(30)) mult_d_d(.a(d), .b(d), .m(d2));
	//assign delta = C_S - d2;
	
	wire [70:0] A_r, B_r; 
	//wire [87:0] delta_r;
	registor #(.WIDTH(71)) A_reg(.clk(clk), .en(line_delay1[2] & line_delay2[1]), .d(A), .q(A_r));
	registor #(.WIDTH(71)) B_reg(.clk(clk), .en(line_delay1[2] & line_delay2[1]), .d(B), .q(B_r));
	//registor #(.WIDTH(88)) delta_reg(.clk(clk), .en(line_delay1[2] & line_delay2[1]), .d(delta), .q(delta_r));
	//---------------------------------------------
	
	//-----------------AMP-------------------------
	wire [141:0] A_r2, B_r2;
	wire [141:0] A_r2_add_B_r2;
	wire [70:0] sqrt_AB;
	signed_mult #(.WIDTH_A(71), .WIDTH_B(71)) mult_Ar_Ar(.a(A_r), .b(A_r), .m(A_r2));
	signed_mult #(.WIDTH_A(71), .WIDTH_B(71)) mult_Br_Br(.a(B_r), .b(B_r), .m(B_r2));
	assign A_r2_add_B_r2 = A_r2 + B_r2;
	SQRT sqrt(.radical(A_r2_add_B_r2), .q(sqrt_AB), .remainder());
	wire [70:0] temp = sqrt_AB >> 52; // 52 константа при рассчете 2048 точек  
	assign amp = temp[9:0];
	
	//---------------------------------------------

endmodule

module pow2
#(parameter WIDTH = 8)
(
input [WIDTH-1:0] a,
output [WIDTH*2-1:0] p
);
	assign p = a ** 2'd2;
endmodule

module table_sin_cos
// таблица синусов и косинусов
// задержка 2 такта, т.к. присутствуют 2 тригера (один от счетчика, другой внутри ROM)
(
input clk, 
input en,
input [7:0] modul_step, // кратность частоты
input [3:0] fractional_step,
output [8:0] cos, sin
);
	reg [14:0] total_address; // общий адресс 
	wire [10:0] address; // адрес подаваемый в таблицу
	reg sign_sin, sign_cos;
	wire [8:0] addr_sin, addr_cos; // адресс подаваемы в таблицу
	wire [8:0] sin_1sym, cos_1sym; // 1-ая симетрия сигнала
	initial begin
		total_address <= 15'b111_1111_1111_1111; // инициализируем счетчик
	end
	ROM rom(.address_a(addr_sin), .address_b(addr_cos), .clock(clk), .q_a(sin_1sym), .q_b(cos_1sym));
	assign address = total_address[14:4];
	assign addr_sin = address[9] ? ~address[8:0] : address[8:0];
	assign addr_cos = ~address[9] ? ~address[8:0] : address[8:0];
	assign sin = sign_sin ? -sin_1sym : sin_1sym;
	assign cos = sign_cos ? -cos_1sym : cos_1sym;
	always @(posedge clk) begin
		if(en) begin
			total_address <= total_address + {modul_step, fractional_step};
		end
		sign_sin <= address[10];
		sign_cos <= address[10] ^ address[9];
	end
endmodule


module accumulator 
#(parameter WIDTH = 8) // ширина шины (по умолчанию)
(
input clk,
input en,
input reset,
input [WIDTH-1:0] a,
output reg [(WIDTH-1+12):0] s // ширина определяется как WIDTH + log(2048)
);
	initial begin
		s <= {(WIDTH-1+12){1'b0}};
	end
	always @(posedge clk) begin
		if(reset) begin
			s <= {(WIDTH-1+12){1'b0}};
		end
		else if(en) begin
			s <= s + {{12{a[WIDTH-1]}},a};
		end
	end
endmodule


module counter 
#(parameter WIDTH = 8)
(
input clk,
input en,
output reg [WIDTH-1:0] cnt
);
	initial begin
		cnt <= {WIDTH{1'b1}}; // инициализируем FFF чтобы очистить регистры
	end
	always @(posedge clk) begin
		if(en) begin
			cnt <= cnt + 1'd1;
		end
	end
endmodule

module registor
#(parameter WIDTH = 8)
(
input clk,
input en,
input [WIDTH-1:0] d,
output reg [WIDTH-1:0] q
);
	always @(posedge clk) begin
		if(en) begin
			q <= d;
		end
	end
endmodule

module signed_mult
#(parameter WIDTH_A = 8, WIDTH_B = 8)
(
input [WIDTH_A-1:0] a, 
input [WIDTH_B-1:0] b,
output [WIDTH_A+WIDTH_B-1:0] m
);
	assign m = {{WIDTH_B{a[WIDTH_A-1]}},a} * {{WIDTH_A{b[WIDTH_B-1]}},b};
endmodule


module unsigned_mult
#(parameter WIDTH_A = 8, WIDTH_B = 8)
(
input [WIDTH_A-1:0] a, 
input [WIDTH_B-1:0] b,
output [WIDTH_A+WIDTH_B-1:0] m
);
	assign m = {{WIDTH_B{1'd0}},a} * {{WIDTH_A{1'd0}},b};
endmodule

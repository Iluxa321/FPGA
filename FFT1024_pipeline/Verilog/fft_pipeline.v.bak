module fft_pipeline
(

input clk,
input reset,
input load,
input start,
input [31:0] in_data,
input [4:0] addr,
output reg fft_done,
output [31:0] o_data



/*input clk,
input rst,
input en,
output [4:0] addr_A,
output [4:0] addr_B,
output [3:0] addr_Tw,
output conv_end*/

/*input clk, 
input reset,
input start,
input done,

output work,
output rst_addr,
output inc_addr,
output WRmem*/

/*input clk,
input [15:0] A_re,
input [15:0] A_img,
input [15:0] B_re,
input [15:0] B_img,
input [15:0] W_re,
input [15:0] W_img,

output [15:0] X_re,
output [15:0] X_img,
output [15:0] Y_re,
output [15:0] Y_img*/

);
	
	wire done, WRmem, work, inc_addr, rst_addr;
	wire [4:0] addr_A, addr_B;
	wire [3:0] addr_Tw;
	
	agu agu(
		.clk(clk),
		.rst(rst_addr),
		.en(inc_addr),
		.addr_A(addr_A),
		.addr_B(addr_B),
		.addr_Tw(addr_Tw),
		.conv_end(done)
		);
	
	controller controller(
		.clk(clk),
		.reset(reset),
		.start(start),
		.done(done),
		.work(work),
		.rst_addr(rst_addr),
		.inc_addr(inc_addr),
		.WRmem(WRmem)
		);
		
	data_path dp(
		.clk(clk),
		.load(load),
		.FFT_work(work),
		.WRmem(WRmem),
		.addr(addr),	// адресс для чтения/записи данных
		.addr_A(addr_A), .addr_B(addr_B), // адресса для преобразования
		.addr_Tw(addr_Tw),
		.in_data(in_data), // данные для загрузки
		.o_data(o_data) // данные для чтения
);	
	
	always @(posedge clk) begin
		if(done) fft_done <= 1'd1;
		else if(work) fft_done <= 1'd0;
	end
	
	
	
	
endmodule



module agu	// address generator unit
(
input clk,
input rst,
input en,
output [4:0] addr_A,
output [4:0] addr_B,
output [3:0] addr_Tw,
output conv_end	// конец преобразования
);

	reg [6:0] cnt;
	wire [2:0] i;
	wire [4:0] j, j1;
	wire [2:0] sub;
	
	always @(posedge clk) begin
		if(rst)
			cnt <= 7'd0;
		else if(en)
			cnt <= cnt + 7'd1;
	end
	
	assign i = cnt[6:4];
	assign j = {cnt[3:0], 1'd0};	// j*2
	assign j1 = j + 1'd1;
	
	rotate rot1(.j(j), .i(i), .shf_j(addr_A));
	rotate rot2(.j(j1), .i(i), .shf_j(addr_B));
	
	assign sub = 3'd4 - i;
	assign conv_end = &sub;	// если произошло переполенния, то преобразование закончилось
	
	wire [7:0] mask;
	assign mask = 8'hF0 >> sub;
	assign addr_Tw = {mask[4], mask[5], mask[6], mask[7]} & j[4:1];


endmodule


module rotate	// циклический сдвиг на i битов
(
input [4:0] j,
input [2:0] i,
output [4:0] shf_j
);
	
	wire [9:0] tmp = {5'd0,j} << i;
	assign shf_j = tmp[4:0] | tmp[9:5];
	
endmodule


module data_path
(
input clk,
input load,
input FFT_work,
input WRmem,
input [4:0] addr,	// адресс для чтения/записи данных
input [4:0] addr_A, addr_B, // адресса для преобразования
input [3:0] addr_Tw,
input [31:0] in_data, // данные для загрузки
output [31:0] o_data // данные для чтения
);

	wire [4:0] _addr_A;
	wire [31:0] A, B, Tw_factor;
	wire [31:0] X, Y;	// выходные данные с бабочки
	wire [31:0] mux_A;
	wire WRmem_A;
	assign _addr_A = ~FFT_work ? addr : addr_A;
	assign WRmem_A = ~FFT_work ? load : WRmem;
	assign mux_A = ~FFT_work ? in_data : X;
	ram ram(
		.address_a(_addr_A),
		.address_b(addr_B),
		.clock(clk),
		.data_a(mux_A),
		.data_b(Y),
		.wren_a(WRmem_A),
		.wren_b(WRmem),
		.q_a(A),
		.q_b(B)
		);
	
	rom rom(
		.address(addr_Tw),
		.clock(clk),
		.q(Tw_factor)
		);
		
	butterfly butterfly(
		.clk(clk),
		.A_re(A[31:16]),
		.A_img(A[15:0]),
		.B_re(B[31:16]),
		.B_img(B[15:0]),
		.W_re(Tw_factor[31:16]),
		.W_img(Tw_factor[15:0]),
		.X_re(X[31:16]),
		.X_img(X[15:0]),
		.Y_re(Y[31:16]),
		.Y_img(Y[15:0])
		);
	
	assign o_data = A;
	
endmodule

module butterfly
(
input clk,
input signed [15:0] A_re,
input signed [15:0] A_img,
input signed [15:0] B_re,
input signed [15:0] B_img,
input signed [15:0] W_re,
input signed [15:0] W_img,

output signed [15:0] X_re,
output signed [15:0] X_img,
output signed [15:0] Y_re,
output signed [15:0] Y_img
);

	reg [15:0] qA_re, qA_img, qB_re, qB_img;
	wire [31:0] b_re, b_img; 
	assign b_re = (B_re * W_re) + (B_img * W_img);
	assign b_img = (B_img * W_re) - (B_re * W_img);
	
	always @(posedge clk) begin
		qA_re <= A_re;
		qA_img <= A_img;
		qB_re <= b_re[30:15];
		qB_img <= b_img[30:15];
	end
	
	assign X_re = qA_re + qB_re;
	assign X_img = qA_img + qB_img;
	assign Y_re = qA_re - qB_re;
	assign Y_img = qA_img - qB_img;

endmodule

module controller
(
input clk, 
input reset,
input start,		// сигнал старта
input done,			// сигнала завершения преобразования

output work,		// отражает работу преобразования
output rst_addr,	// сброс agu
output inc_addr,	// увеличение agu
output WRmem		// разрешение записи в RAM
);
	wire en_cnt, rst_cnt;
	reg [5:0] control;
	reg [1:0] cnt;	// служит для формирования задержки
	
	initial begin
		cnt <= 2'd0;
	end
	
	assign {work, rst_addr, inc_addr, WRmem, rst_cnt, en_cnt} = control;
	
	reg [1:0] state, next;
	parameter [1:0] RESET = 2'd0,
						 IDLE = 2'd1,
						 WAIT = 2'd2,
						 INC = 2'd3;
	
	parameter [1:0] cnt_wait = 2'd2; // величина задержки 
	
	always @(posedge clk) begin
		if(reset) state <= RESET;
		else state <= next;
	end
	
	always @(posedge clk) begin
		if(rst_cnt) cnt <= 2'd0;
		else if(en_cnt) cnt <= cnt + 2'd1;
	end

	always @(state or start or done or cnt) begin
		case(state)
			RESET: begin
				control = 6'b110010;
				next = IDLE;
			end
			IDLE: begin
				control = 6'b000000;
				if(start) next = WAIT;
				else next = IDLE;
				
			end
			WAIT: begin
				control = 6'b100001;
				if(done) next = RESET;
				else if(cnt == cnt_wait) next = INC;
				else next = WAIT;
			end
			INC: begin
				control = 6'b101110;
				next = WAIT;
			end
		endcase
	
	end


endmodule
